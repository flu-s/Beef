package com.project.beef.service;

import com.project.beef.domain.Cut;
import com.project.beef.dto.CutDto; // CutDto import 추가
import com.project.beef.repository.CutRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.core.io.Resource; // MultipartFile.getResource() 반환 타입을 Resource로 지정
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;

@Service
@Transactional // DB 작업이 포함될 수 있으므로 트랜잭션 처리
@RequiredArgsConstructor
public class CutService {
    
    private final CutRepository cutRepository;
    private final RestTemplate restTemplate; // ⭐ RestTemplate을 생성자 주입으로 변경

    // AI 서버 주소 (application.properties나 @Value를 통해 설정하는 것이 일반적이나, 현재는 하드코딩 유지)
    private static final String AI_SERVER_URL = "http://localhost:5000/predict";

    public List<Cut> getList() {
        return cutRepository.findAll();
    }

    /**
     * 업로드된 파일을 파이썬 AI 서버로 전송하고, 분석 결과를 CutDto로 반환합니다.
     * @param file 클라이언트가 업로드한 이미지 파일
     * @return AI 분석 결과가 담긴 CutDto
     * @throws Exception 통신 오류 발생 시
     */
    public CutDto analyzeAndSaveCut(MultipartFile file) throws Exception {
        
        CutDto analysisResult;

        try {
            // 2. Multipart 전송 설정 및 본문 구성
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.MULTIPART_FORM_DATA);
            
            // MultipartFile의 Resource를 요청 본문에 추가
            MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
            body.add("file", file.getResource()); 
            
            HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);
            
            // 3. 분석 요청 (Flask 서버 호출)
            // AI 서버 응답을 Map<String, Object>로 받습니다.
            // Map.class 대신 AI 서버 응답 DTO 클래스를 사용하는 것이 좋습니다.
            Map<String, Object> aiResponse = restTemplate.postForObject(AI_SERVER_URL, requestEntity, Map.class);
            
            if (aiResponse == null) {
                 throw new Exception("AI 서버로부터 유효한 응답을 받지 못했습니다.");
            }

            // 4. 결과 매핑 및 CutDto 생성
            analysisResult = new CutDto(
                "success", // 상태 필드는 통신 성공 시 "success"로 가정
                (String) aiResponse.get("detectedPart"),     // 부위 결과
                (String) aiResponse.get("detectedGrade"),    // 등급 결과
                (Integer) aiResponse.get("marblingRatio"),   // 마블링 지수
                (String) aiResponse.get("insight")           // 분석 요약
            );
            
            // 5. (선택적) DB 저장 로직: CutEntity를 생성하여 저장
            /*
            Cut cut = Cut.builder()
                .detectedPart(analysisResult.getDetectedPart())
                .detectedGrade(analysisResult.getDetectedGrade())
                .marblingRatio(analysisResult.getMarblingRatio())
                .insight(analysisResult.getInsight())
                .fileName(file.getOriginalFilename())
                .visualizedUrl(analysisResult.getVisualizedUrl()) // 혹은 /images/analysis/mask_latest.png
                .build();
            cutRepository.save(cut);
            */

        } catch (Exception e) {
            e.printStackTrace();
            // 통신 실패 시 기본 오류 DTO 반환
            return new CutDto("error", null, null, null, "분석 서버 통신 오류 또는 데이터 처리 오류: " + e.getMessage());
        }
        
        return analysisResult;
    }
}