package com.project.beef.service;

import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import com.project.beef.domain.Cut;
import com.project.beef.repository.CutRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class CutService {

    private final CutRepository cutRepository;

    public List<Cut> getList() {
        return cutRepository.findAll();
    }
    
    /**
     * AI 분석 및 등급 리포트 데이터 생성
     */
 // Roboflow 설정 정보 (프로젝트 설정에서 확인 가능)
    private final String API_KEY = "rt6lrLHzDWIjJ0ihMv7o"; // 본인 키로 교체
    private final String MODEL_ENDPOINT = "beef_cut-6tafn-fn4xe/2"; // 본인 모델 주소

    public Map<String, Object> analyzeMeat(MultipartFile file) {
        Map<String, Object> result = new HashMap<>();

        try {
            // [Logic 1] 실제 Roboflow AI 서버 호출
            // 이미지를 Base64로 인코딩하여 전송하거나 multipart 전송
            byte[] bytes = file.getBytes();
            String encodedImage = Base64.getEncoder().encodeToString(bytes);

            RestTemplate restTemplate = new RestTemplate();
            String url = "https://detect.roboflow.com/" + MODEL_ENDPOINT + "?api_key=" + API_KEY;
            
            // API 호출 및 결과 파싱 (간략화된 예시)
            // Roboflow는 인식된 객체의 클래스명과 신뢰도를 JSON으로 돌려줍니다.
            Map<String, Object> aiResponse = restTemplate.postForObject(url, encodedImage, Map.class);
            
            // AI가 판별한 가장 확률 높은 등급 추출 (로직에 맞춰 파싱 필요)
            String detectedGrade = parseGrade(aiResponse); 
            double detectedMarbling = calculateMarblingRatio(aiResponse); // 수치 계산 로직

            // [Logic 2] 분석 결과 구성
            result.put("grade", detectedGrade);
            result.put("marblingRatio", detectedMarbling);
            result.put("insight", getInsightMessage(detectedGrade, detectedMarbling));
            result.put("visualizedUrl", "/images/analysis/mask_latest.png");

        } catch (Exception e) {
            e.printStackTrace();
            result.put("grade", "분석 실패");
            result.put("insight", "서버 통신 중 오류가 발생했습니다.");
        }

        return result;
    }

 // parseGrade 메서드를 실제 응답에 맞게 수정
    private String parseGrade(Map<String, Object> aiResponse) {
        try {
            List<Map<String, Object>> predictions = (List<Map<String, Object>>) aiResponse.get("predictions");
            if (predictions != null && !predictions.isEmpty()) {
                // 가장 확률(confidence)이 높은 예측값의 클래스명을 가져옴
                return (String) predictions.get(0).get("class");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return "판독 불가"; 
    }
}
