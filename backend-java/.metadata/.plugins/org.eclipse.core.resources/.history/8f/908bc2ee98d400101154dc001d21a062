package com.project.beef.service;

import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import com.project.beef.domain.Cut;
import com.project.beef.repository.CutRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class CutService {

    private final CutRepository cutRepository;

    public List<Cut> getList() {
        return cutRepository.findAll();
    }
    
    /**
     * AI 분석 및 등급 리포트 데이터 생성
     */
 // Roboflow 설정 정보 (프로젝트 설정에서 확인 가능)
    private final String API_KEY = "rt6lrLHzDWIjJ0ihMv7o"; // 본인 키로 교체
    private final String MODEL_ENDPOINT = "beef_cut-6tafn-fn4xe/2"; // 본인 모델 주소

    public Map<String, Object> analyzeMeat(MultipartFile file) {
        Map<String, Object> result = new HashMap<>();

        try {
            // [Logic 1] 실제 Roboflow AI 서버 호출
            // 이미지를 Base64로 인코딩하여 전송하거나 multipart 전송
            byte[] bytes = file.getBytes();
            String encodedImage = Base64.getEncoder().encodeToString(bytes);

            RestTemplate restTemplate = new RestTemplate();
            String url = "https://detect.roboflow.com/" + MODEL_ENDPOINT + "?api_key=" + API_KEY;
            
            // API 호출 및 결과 파싱 (간략화된 예시)
            // Roboflow는 인식된 객체의 클래스명과 신뢰도를 JSON으로 돌려줍니다.
            Map<String, Object> aiResponse = restTemplate.postForObject(url, encodedImage, Map.class);
            
            // AI가 판별한 가장 확률 높은 등급 추출 (로직에 맞춰 파싱 필요)
            String detectedGrade = parseGrade(aiResponse); 
            double detectedMarbling = calculateMarblingRatio(aiResponse); // 수치 계산 로직

            // [Logic 2] 분석 결과 구성
            result.put("grade", detectedGrade);
            result.put("marblingRatio", detectedMarbling);
            result.put("insight", getInsightMessage(detectedGrade, detectedMarbling));
            result.put("visualizedUrl", "/images/analysis/mask_latest.png");

        } catch (Exception e) {
            e.printStackTrace();
            result.put("grade", "분석 실패");
            result.put("insight", "서버 통신 중 오류가 발생했습니다.");
        }

        return result;
    }

 // parseGrade 메서드를 실제 응답에 맞게 수정
    private String parseGrade(Map<String, Object> aiResponse) {
        try {
            List<Map<String, Object>> predictions = (List<Map<String, Object>>) aiResponse.get("predictions");
            if (predictions != null && !predictions.isEmpty()) {
                // 가장 확률(confidence)이 높은 예측값의 클래스명을 가져옴
                return (String) predictions.get(0).get("class");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return "판독 불가"; 
    }
    
    /**
     * AI 응답 데이터(JSON)에서 확률이 가장 높은 등급(class)을 추출
     */
    private String parseGrade(Map<String, Object> aiResponse) {
        try {
            List<Map<String, Object>> predictions = (List<Map<String, Object>>) aiResponse.get("predictions");
            if (predictions != null && !predictions.isEmpty()) {
                // 첫 번째 예측값(가장 높은 신뢰도)의 클래스 명을 반환 (예: 1++, 1+, 2 등)
                return (String) predictions.get(0).get("class");
            }
        } catch (Exception e) {
            System.err.println("Grade parsing error: " + e.getMessage());
        }
        return "판독 불가";
    }

    /**
     * AI가 예측한 신뢰도(Confidence)를 바탕으로 마블링 지수 수치화
     */
    private double calculateMarblingRatio(Map<String, Object> aiResponse) {
        try {
            List<Map<String, Object>> predictions = (List<Map<String, Object>>) aiResponse.get("predictions");
            if (predictions != null && !predictions.isEmpty()) {
                double confidence = (double) predictions.get(0).get("confidence");
                // 0.98 -> 98.0 점 형태로 변환
                return Math.round(confidence * 1000) / 10.0;
            }
        } catch (Exception e) {
            System.err.println("Marbling ratio calculation error: " + e.getMessage());
        }
        return 0.0;
    }

    /**
     * 등급과 수치에 기반한 전문가 의견(Insight) 매칭
     */
    private String getInsightMessage(String grade, double ratio) {
        if ("1++".equals(grade) && ratio > 15.0) {
            return "근내지방이 매우 풍부하며 선홍색 육색이 선명하여 최상의 부드러움을 제공합니다.";
        } else if (ratio > 10.0) {
            return "마블링 분포가 적절하여 씹는 맛과 고소한 풍미의 밸런스가 뛰어납니다.";
        }
        return "살코기 비중이 높아 담백한 풍미를 선호하는 분들께 적합한 육질입니다.";
    }
}
