package com.project.beef.service;

import java.util.Base64;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import com.project.beef.domain.Cut;
import com.project.beef.repository.CutRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class CutService {

    private final CutRepository cutRepository;

    // TODO: 본인의 Roboflow API 키와 모델 엔드포인트로 확인 및 교체하세요.
    private final String API_KEY = "rf_aTgKNoMoeUg3KQJoY6a62qqGkK72"; 
    private final String MODEL_ENDPOINT = "beef_cut-6tafn-fn4xe/2"; 

    public List<Cut> getList() {
        return cutRepository.findAll();
    }

    /**
     * AI 분석 및 등급 리포트 데이터 생성 (실제 API 연동 버전)
     */
    public Map<String, Object> analyzeMeat(MultipartFile file) {
        Map<String, Object> result = new HashMap<>();

        try {
            // [Logic 1] 이미지를 Base64로 인코딩하여 Roboflow에 전송 준비
            byte[] bytes = file.getBytes();
            String encodedImage = Base64.getEncoder().encodeToString(bytes);

            RestTemplate restTemplate = new RestTemplate();
            String url = "https://detect.roboflow.com/" + MODEL_ENDPOINT + "?api_key=" + API_KEY;
            
            // AI 서버 호출 (Inference API)
            Map<String, Object> aiResponse = restTemplate.postForObject(url, encodedImage, Map.class);
            
            // [Logic 2] 응답 데이터 파싱 및 가공 (등급 및 마블링 수치 추출)
            String detectedGrade = parseGrade(aiResponse); 
            double detectedMarbling = calculateMarblingRatio(aiResponse); 

            // [Logic 3] 웹 리포트용 최종 데이터 구성
            result.put("grade", detectedGrade);
            result.put("marblingRatio", detectedMarbling);
            result.put("insight", getInsightMessage(detectedGrade, detectedMarbling));
            
            // 시각화 URL (추후 OpenCV 마스크 생성 시 경로 매핑)
            result.put("visualizedUrl", "/images/analysis/mask_latest.png");

        } catch (Exception e) {
            e.printStackTrace();
            result.put("grade", "분석 실패");
            result.put("insight", "서버 통신 중 오류가 발생했습니다. (용량 초과 혹은 네트워크 문제)");
        }

        return result;
    }

    /**
     * AI 응답 데이터(JSON)에서 확률이 가장 높은 등급(class)을 추출
     */
    private String parseGrade(Map<String, Object> aiResponse) {
        try {
            List<Map<String, Object>> predictions = (List<Map<String, Object>>) aiResponse.get("predictions");
            if (predictions != null && !predictions.isEmpty()) {
                // 첫 번째 예측값(가장 높은 신뢰도)의 클래스 명을 반환 (예: 1++, 1+, 2 등)
                return (String) predictions.get(0).get("class");
            }
        } catch (Exception e) {
            System.err.println("Grade parsing error: " + e.getMessage());
        }
        return "판독 불가";
    }

    /**
     * AI가 예측한 신뢰도(Confidence)를 바탕으로 마블링 지수 수치화
     */
    private double calculateMarblingRatio(Map<String, Object> aiResponse) {
        try {
            List<Map<String, Object>> predictions = (List<Map<String, Object>>) aiResponse.get("predictions");
            if (predictions != null && !predictions.isEmpty()) {
                double confidence = (double) predictions.get(0).get("confidence");
                // 0.98 -> 98.0 점 형태로 변환
                return Math.round(confidence * 1000) / 10.0;
            }
        } catch (Exception e) {
            System.err.println("Marbling ratio calculation error: " + e.getMessage());
        }
        return 0.0;
    }

    /**
     * 등급과 수치에 기반한 전문가 의견(Insight) 매칭
     */
    private String getInsightMessage(String grade, double ratio) {
        if ("1++".equals(grade) && ratio > 15.0) {
            return "근내지방이 매우 풍부하며 선홍색 육색이 선명하여 최상의 부드러움을 제공합니다.";
        } else if (ratio > 10.0) {
            return "마블링 분포가 적절하여 씹는 맛과 고소한 풍미의 밸런스가 뛰어납니다.";
        }
        return "살코기 비중이 높아 담백한 풍미를 선호하는 분들께 적합한 육질입니다.";
    }
}