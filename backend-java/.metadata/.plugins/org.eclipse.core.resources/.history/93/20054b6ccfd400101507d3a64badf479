package com.project.beef.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.project.beef.domain.Cut;
import com.project.beef.dto.CutDto;
import com.project.beef.dto.SaveRequestDto;
import com.project.beef.service.CutService;

import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/cut") 
@RequiredArgsConstructor
public class CutController {

    private final CutService cutService;

    /**
     * 1. POST /api/cut/analyze : 부위 측정 및 DB 저장 통합 API (수정됨)
     * 클라이언트가 보낸 이미지 파일로 부위 분석 후, 그 결과를 DB에 저장합니다.
     */
    @PostMapping("/analyze")
    public ResponseEntity<?> analyzeAndSave(@RequestParam("file") MultipartFile file, HttpServletRequest request) {
        
        if (file.isEmpty()) {
            return ResponseEntity.badRequest().body("업로드할 파일이 없습니다.");
        }

        try {
            // 1. 부위 분석 (AI 서버 통신)
            CutDto partResult = cutService.analyzePart(file);
            
            // 2. (임시) 등급 분석 (현재 미구현/미사용으로 가정하고 기본값 설정)
            // 실제 서비스에서는 analyzeGrade를 호출하여 결과를 통합해야 합니다.
            
            // 3. SaveRequestDto 생성 및 DB 저장
            SaveRequestDto saveDto = SaveRequestDto.builder()
                .detectedPart(partResult.getDetectedPart())
                .detectedGrade("미측정") // 임시 값
                .marblingRatio(0) // 임시 값
                .insight(partResult.getInsight())
                .fileName(file.getOriginalFilename())
                // .memberId(request.getUserPrincipal() != null ? request.getUserPrincipal().getName() : "anonymous") // 사용자 ID가 있다면 추가
                .build();
                
            // DB 저장 메서드 호출
            cutService.saveAnalysisResult(saveDto);
            System.out.println("✅ 분석 결과 DB 저장 성공: " + saveDto.getDetectedPart());

            // 4. 최종 분석 결과 DTO를 클라이언트에게 반환
            return ResponseEntity.ok(partResult); 
            
        } catch (Exception e) {
            System.err.println("분석 및 저장 중 오류 발생: " + e.getMessage());
            // 클라이언트에게 500 오류와 함께 상세 메시지를 전달합니다.
            return ResponseEntity.internalServerError().body("분석 및 저장 처리 중 오류가 발생했습니다: " + e.getMessage());
        }
    }
    
    /**
     * 2. POST /api/cut/grade : 등급 측정 API (기존 로직 유지)
     */
    @PostMapping("/grade")
    public ResponseEntity<?> analyzeGrade(@RequestParam("file") MultipartFile file, HttpServletRequest request) {
        
        if (file.isEmpty()) {
            return ResponseEntity.badRequest().body("업로드할 파일이 없습니다.");
        }

        try {
            CutDto gradeResult = cutService.analyzeGrade(file); 
            return ResponseEntity.ok(gradeResult); 
            
        } catch (Exception e) {
            System.err.println("등급 분석 중 오류 발생: " + e.getMessage());
            return ResponseEntity.internalServerError().body("등급 분석 처리 중 오류가 발생했습니다: " + e.getMessage());
        }
    }
    
    /**
     * 3. POST /api/cut/save : 결과 저장 API (기존 로직 유지)
     * *주의*: 현재 /analyze에서 저장까지 처리하므로 이 API는 사용되지 않을 수 있습니다.
     */
    @PostMapping("/save")
    public ResponseEntity<?> saveResult(@RequestBody SaveRequestDto saveRequest) {
        try {
            Cut savedCut = cutService.saveAnalysisResult(saveRequest);
            
            // 저장된 결과를 클라이언트에게 반환 (저장된 ID 포함)
            return ResponseEntity.ok(savedCut.getId()); 
            
        } catch (Exception e) {
            System.err.println("결과 저장 중 오류 발생: " + e.getMessage());
            return ResponseEntity.internalServerError().body("결과 저장 처리 중 오류가 발생했습니다: " + e.getMessage());
        }
    }
}