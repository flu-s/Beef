package com.project.beef.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import com.project.beef.domain.Cut;
import com.project.beef.dto.CutDto;
import com.project.beef.dto.SaveRequestDto;
import com.project.beef.service.CutService;

import java.security.Principal; 
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/cut") 
@RequiredArgsConstructor
public class CutController {

    private final CutService cutService;

    /**
     * POST /api/cut/analyze : 부위 측정 + 등급 측정 + Insight 결합 + DB 저장 통합 API
     */
    @PostMapping("/analyze")
    public ResponseEntity<CutDto> analyzeAndSave(@RequestParam("file") MultipartFile file, Principal principal) {
        
        if (file.isEmpty()) {
            return ResponseEntity.badRequest().body(null); 
        }

        String memberId = null;
        if (principal != null) {
            memberId = principal.getName(); 
            System.out.println("DEBUG: 현재 로그인 사용자 ID: " + memberId);
        } else {
            System.err.println("경고: 인증 정보(Principal)가 없어 memberId를 저장할 수 없습니다. Anonymous 처리.");
        }

        try {
            // ⭐ 1. analyzePart, analyzeGrade 대신 analyzeAndCombine만 호출 ⭐
            // 이 메서드가 Service에서 모든 분석, Insight 결합, 파일 스트림 처리를 담당합니다.
            CutDto combinedResult = cutService.analyzeAndCombine(file);
            System.out.println("DEBUG: 통합 분석 완료 -> 부위: " + combinedResult.getDetectedPart() + " / 등급: " + combinedResult.getDetectedGrade());

            // 2. 최종 결과 DTO 정리 및 '판정 불가' 처리
            String grade = combinedResult.getDetectedGrade();
            if (grade == null || grade.trim().isEmpty()) {
                grade = "판정 불가";
            }
            
            // Service의 결과를 그대로 사용하므로, Insight 재결합 로직은 제거
            CutDto finalResult = CutDto.builder()
                .status("success")
                .detectedPart(combinedResult.getDetectedPart())
                .detectedGrade(grade) // 판정 불가 처리된 등급 사용
                .insight(combinedResult.getInsight()) // Service에서 결합된 최종 Insight
                .memberId(memberId) 
                .build();
            
            // 3. DB 저장 로직
            SaveRequestDto saveDto = SaveRequestDto.builder()
                .detectedPart(finalResult.getDetectedPart())
                .detectedGrade(finalResult.getDetectedGrade())
                .insight(finalResult.getInsight())
                .fileName(file.getOriginalFilename())
                .memberId(memberId)
                .build();
                
            cutService.saveAnalysisResult(saveDto);
            System.out.println("✅ 분석 결과 DB 저장 성공: " + saveDto.getDetectedPart() + "/" + saveDto.getDetectedGrade() + " by Member: " + saveDto.getMemberId());

            return ResponseEntity.ok(finalResult); 
            
        } catch (Exception e) {
            System.err.println("❌ 분석 및 저장 중 치명적인 오류 발생: " + e.getMessage());
            e.printStackTrace(); 
            return ResponseEntity.internalServerError().body(null); 
        }
    }
    
    // --- 나머지 엔드포인트는 변경 불필요 ---
    
    @PostMapping("/grade")
    public ResponseEntity<?> analyzeGrade(@RequestParam("file") MultipartFile file, HttpServletRequest request) {
        
        if (file.isEmpty()) {
            return ResponseEntity.badRequest().body("업로드할 파일이 없습니다.");
        }

        try {
            // CutService.analyzeGrade 호출은 그대로 유지 (단일 등급 분석 필요 시)
            CutDto gradeResult = cutService.analyzeGrade(file); 
            return ResponseEntity.ok(gradeResult); 
            
        } catch (Exception e) {
            System.err.println("등급 분석 중 오류 발생: " + e.getMessage());
            return ResponseEntity.internalServerError().body("등급 분석 처리 중 오류가 발생했습니다: " + e.getMessage());
        }
    }
    
    @PostMapping("/save")
    public ResponseEntity<?> saveResult(@RequestBody SaveRequestDto saveRequest) {
        try {
            Cut savedCut = cutService.saveAnalysisResult(saveRequest);
            return ResponseEntity.ok(savedCut.getId()); 
            
        } catch (Exception e) {
            System.err.println("결과 저장 중 오류 발생: " + e.getMessage());
            return ResponseEntity.internalServerError().body("결과 저장 처리 중 오류가 발생했습니다: " + e.getMessage());
        }
    }
}