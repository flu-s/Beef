@RestController
@RequestMapping("/api/cut") 
@RequiredArgsConstructor
public class CutController {

    private final CutService cutService;

    /**
     * POST /api/cut/analyze : 부위 측정 + 등급 측정 + DB 저장 통합 API
     */
    @PostMapping("/analyze")
    public ResponseEntity<CutDto> analyzeAndSave(@RequestParam("file") MultipartFile file, Principal principal) {
        
        if (file.isEmpty()) {
            return ResponseEntity.badRequest().body(null); 
        }

        // 1. 현재 사용자 ID 추출
        String memberId = null;
        if (principal != null) {
            memberId = principal.getName(); 
            System.out.println("DEBUG: 현재 로그인 사용자 ID: " + memberId);
        } else {
            System.err.println("경고: 인증 정보(Principal)가 없어 memberId를 저장할 수 없습니다. Anonymous 처리.");
        }

        try {
            // 2. 부위 분석 (AI 서버 통신)
            // CutService.java에서 analyzeAndCombine 메서드를 사용하도록 변경하는 것이 더 좋지만,
            // 현재 구조를 유지하기 위해 Controller에서 직접 호출합니다.
            
            // ⚠️ 주의: 이 파일 업로드(MultipartFile)가 두 번의 AI 서버 호출(analyzePart, analyzeGrade)에
            // 모두 정상적으로 사용되는지 테스트 환경에서 확인해야 합니다.
            CutDto partResult = cutService.analyzePart(file);
            System.out.println("DEBUG: 부위 분석 완료 -> " + partResult.getDetectedPart());

            // 등급 분석 시 analyzePart에서 이미 파일을 소비했을 가능성 (I/O 스트림)이 있다면
            // AI 서버 통신 전에 파일을 다시 준비해야 합니다. (CutService 내부의 callAiServer가 처리한다고 가정)
            CutDto gradeResult = cutService.analyzeGrade(file);
            System.out.println("DEBUG: 등급 분석 완료 -> " + gradeResult.getDetectedGrade() + " (" + gradeResult.getMarblingRatio() + ")");
            
            // --- ⭐ 4. 최종 결과 DTO 생성 및 데이터 통합 (Null/Empty 값 대체 로직 추가) ⭐ ---
            
            // A. 등급 (detectedGrade) 필터링: null 또는 빈 문자열일 경우 "판정 불가"로 대체
            String grade = gradeResult.getDetectedGrade();
            if (grade == null || grade.trim().isEmpty()) {
                grade = "판정 불가"; // 프론트엔드에서 '학습 대기 중' 대신 '판정 불가'가 보이게 됩니다.
            }

            // B. 등급 분석 상세 설명 (insight) 필터링: null 또는 빈 문자열일 경우 대체
            String partInsight = partResult.getInsight();
            if (partInsight == null || partInsight.trim().isEmpty()) {
                partInsight = "부위 분석 상세 정보 없음";
            }
            
            String gradeInsight = gradeResult.getInsight();
            if (gradeInsight == null || gradeInsight.trim().isEmpty()) {
                gradeInsight = "분석 상세 정보 없음";
            }
            
            // 최종 결과 DTO 생성
            CutDto finalResult = CutDto.builder()
                .status("success")
                .detectedPart(partResult.getDetectedPart())
                .detectedGrade(grade) // 필터링된 등급 사용
                .marblingRatio(gradeResult.getMarblingRatio())
                
                // ⭐⭐⭐ 이 부분을 수정했습니다. (\n 삽입) ⭐⭐⭐
                // 클라이언트(React)에서 white-space: pre-wrap; 스타일을 적용해야 줄 바꿈이 보입니다.
                .insight(partInsight + "\n" + "(등급 분석: " + gradeInsight + ")") 
                
                .memberId(memberId) 
                .build();
            
            // 5. SaveRequestDto 생성 및 DB 저장
            // DTO 빌더를 사용하여 최종 데이터를 DB 저장용 DTO에 매핑합니다.
            SaveRequestDto saveDto = SaveRequestDto.builder()
                .detectedPart(finalResult.getDetectedPart())
                .detectedGrade(finalResult.getDetectedGrade()) // 필터링된 등급 저장
                .marblingRatio(finalResult.getMarblingRatio())
                .insight(finalResult.getInsight())
                .fileName(file.getOriginalFilename())
                .memberId(memberId)
                .build();
                
            cutService.saveAnalysisResult(saveDto);
            System.out.println("✅ 분석 결과 DB 저장 성공: " + saveDto.getDetectedPart() + "/" + saveDto.getDetectedGrade() + " by Member: " + saveDto.getMemberId());

            // 6. 최종 분석 결과 DTO를 클라이언트에게 반환
            return ResponseEntity.ok(finalResult); 
            
        } catch (Exception e) {
            System.err.println("❌ 분석 및 저장 중 치명적인 오류 발생: " + e.getMessage());
            e.printStackTrace(); 
            // 클라이언트에게 500 오류 응답을 보냅니다.
            return ResponseEntity.internalServerError().body(null); 
        }
    }
    
    // ... (analyzeGrade 및 saveResult 메서드는 생략, 수정 없음)
    
    /**
     * 2. POST /api/cut/grade : 등급 측정 API (단독 호출 시 - 기존 로직 유지)
     */
    @PostMapping("/grade")
    public ResponseEntity<?> analyzeGrade(@RequestParam("file") MultipartFile file, HttpServletRequest request) {
        
        if (file.isEmpty()) {
            return ResponseEntity.badRequest().body("업로드할 파일이 없습니다.");
        }

        try {
            CutDto gradeResult = cutService.analyzeGrade(file); 
            return ResponseEntity.ok(gradeResult); 
            
        } catch (Exception e) {
            System.err.println("등급 분석 중 오류 발생: " + e.getMessage());
            return ResponseEntity.internalServerError().body("등급 분석 처리 중 오류가 발생했습니다: " + e.getMessage());
        }
    }
    
    /**
     * 3. POST /api/cut/save : 결과 저장 API (단독 호출 시 - 기존 로직 유지)
     */
    @PostMapping("/save")
    public ResponseEntity<?> saveResult(@RequestBody SaveRequestDto saveRequest) {
        try {
            Cut savedCut = cutService.saveAnalysisResult(saveRequest);
            return ResponseEntity.ok(savedCut.getId()); 
            
        } catch (Exception e) {
            System.err.println("결과 저장 중 오류 발생: " + e.getMessage());
            return ResponseEntity.internalServerError().body("결과 저장 처리 중 오류가 발생했습니다: " + e.getMessage());
        }
    }
}